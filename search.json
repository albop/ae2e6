[
  {
    "objectID": "tutorials/session_1/index_correction.html",
    "href": "tutorials/session_1/index_correction.html",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "",
    "text": "Objectives\n\n\n\n\n\n\nIntroduce Julia environment\n\nrun cells\nbasic types: numbers, strings, vectors, matrices\nfunctions\nsimple plots\n\nSimulate AR1 models\n\nimpulse response functions\nstochastic simulations\n\nconditional / unconditional moments\n\ndevelop intuition about eigenvalues / ergodic distributions\n\nLearn the Dyno mini-interface\n\ncheck the steady-state\nunderstand the meaning of shocks (exogenous variables, innovations)\nunderstand the outputs (decision rule, simulation, graphs)\ninterpret IRFs (persistence, magnitude, …)"
  },
  {
    "objectID": "tutorials/session_1/index_correction.html#why-julia",
    "href": "tutorials/session_1/index_correction.html#why-julia",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Why Julia?",
    "text": "Why Julia?\nDevelopped at MIT on top of opensource technologies\n\nlinux / git / llvm\n\nSyntax inspired by Matlab but:\n\nmore consistent\nlots of features from high level languages\n\nEverything is JIT-compiled\n\nno interpreted vs compiled treadeoff -&gt; very fast\nmost of the base library is written in Julia\n\nOpensource/free + vibrant community"
  },
  {
    "objectID": "tutorials/session_1/index_correction.html#numbers",
    "href": "tutorials/session_1/index_correction.html#numbers",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Numbers",
    "text": "Numbers\n\n# numbers (usual operations usual)\n(1.0+(2.0+3.0*(4.0+5.0)))/30\n\n1.0\n\n\n\n# exponentials are denoted by ^\n2^8\n\n256"
  },
  {
    "objectID": "tutorials/session_1/index_correction.html#variables-assignments-comparisons",
    "href": "tutorials/session_1/index_correction.html#variables-assignments-comparisons",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Variables / assignments / comparisons",
    "text": "Variables / assignments / comparisons\n\n# variable assignment\nx = 10\n\n10\n\n\n\n# Variable names can have Unicode characters\n# To get ϵ in the REPL, type \\epsilon&lt;TAB&gt;\na = 20\nσ = 34\nϵ = 1e-4\n\n0.0001\n\n\n\n# comparison \n2 == 3\n\nfalse\n\n\n\n3&lt;=3\n\ntrue"
  },
  {
    "objectID": "tutorials/session_1/index_correction.html#strings",
    "href": "tutorials/session_1/index_correction.html#strings",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Strings",
    "text": "Strings\n\n# Strings can also contain Unicode characters\nfancy_str = \"α is a string\"\n\n\"α is a string\"\n\n\n\n# double quotes define a character, not a string\n'c' \n\n'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n\n\n\n# string interpolation (1/2)\nhe_who_must_not_be_named = \"Voldemort\"\n\"Welcome $(he_who_must_not_be_named)!\"\n\n\"Welcome Voldemort!\"\n\n\n\n# string interpolation (2/2)\nn = 1999999\nprintln(\"Iteration \", n, \" is still running...\")\n\nIteration 1999999 is still running..."
  },
  {
    "objectID": "tutorials/session_1/index_correction.html#arrays",
    "href": "tutorials/session_1/index_correction.html#arrays",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Arrays",
    "text": "Arrays\n\n# vectors\nv = [1,2,3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n# matrices \nM = [1 2 3 ; 4 5 6 ; 7 8 9]\n\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\n\n\n# matrix multiplication\nM*v\n\n3-element Vector{Int64}:\n 14\n 32\n 50\n\n\n\n# mutating vectors\nx = [\"One\"]\npush!(x, \"Two\")\npush!(x, \"Three\")\npush!(x, \"Four\")\npush!(x, \"Five\")\n\n# Note how the type of the vector is different from above\n# Vectors in Julia hold homoegenous types\n\n# Also note the exclation mark in `push!`: it is a reminder\n# of the fact that `push!` mutates its first argument\n\n5-element Vector{String}:\n \"One\"\n \"Two\"\n \"Three\"\n \"Four\"\n \"Five\"\n\n\n\n# access elements in a vector\nv[1]\n\n1\n\n\n\n# access elements in a matrix\nM[1,2]\n\n2\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIndexing in Julia is 1-based. First element of a collection is denoted by 1.\n\n\n\n# slice matrices\nprintln(M)\n\n# keep first line\nprintln(\"First line\")\nprintln(M[1,:])\n\n# keep second column\nprintln(\"Second column\")\nprintln(M[:,2])\n\n# extract a submatrix\nprintln(M[1:2,1:2])\n\n[1 2 3; 4 5 6; 7 8 9]\nFirst line\n[1, 2, 3]\nSecond column\n[2, 5, 8]\n[1 2; 4 5]\n\n\n\n# concatenate vectors (horizontally)\nvcat( [1,2], [3,4])\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n\n# concatenate vectors\nhcat( [1,2], [3,4])\n\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\n\n\n# transpose matrix\nhcat( [1,2], [3,4])'\n\n2×2 adjoint(::Matrix{Int64}) with eltype Int64:\n 1  2\n 3  4"
  },
  {
    "objectID": "tutorials/session_1/index_correction.html#tuples",
    "href": "tutorials/session_1/index_correction.html#tuples",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Tuples",
    "text": "Tuples\n\n# like in python\n# tuples can hold heterogenous data\nt = (\"This\", \"is\", 1, \"tuple\")\n\n(\"This\", \"is\", 1, \"tuple\")\n\n\n\n# access elements in a tuple (still 1-based)\nt[3]\n\n1\n\n\n\n# tuples are `immutable`\n# The following should raise an exception\npush!(t, \"not a vector\")\n\nMethodError: MethodError: no method matching push!(::Tuple{String, String, Int64, String}, ::String)\n\nClosest candidates are:\n  push!(::Any, ::Any, !Matched::Any)\n   @ Base abstractarray.jl:3389\n  push!(::Any, ::Any, !Matched::Any, !Matched::Any...)\n   @ Base abstractarray.jl:3390\n  push!(!Matched::Set, ::Any)\n   @ Base set.jl:103\n  ..."
  },
  {
    "objectID": "tutorials/session_1/index_correction.html#loops",
    "href": "tutorials/session_1/index_correction.html#loops",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Loops",
    "text": "Loops\n\n# loop over any iterable (like in python)\nfor i in 1:5\n    println(\"Iteration \", i)\nend\n# note how 1 and 5 are both included.\n\nIteration 1\nIteration 2\nIteration 3\nIteration 4\nIteration 5\n\n\n\nfor i ∈ [\"Paris\", \"New-York\", \"Bogota\"]\n    println(\"City: \", i)\nend\n\nCity: Paris\nCity: New-York\nCity: Bogota\n\n\n\n# Vector comprehensions (like in python)\n# enumerate all squares of even numbers (% computes modulo)\n[i^2 for i=1:10 if i%2==1]\n\n5-element Vector{Int64}:\n  1\n  9\n 25\n 49\n 81"
  },
  {
    "objectID": "tutorials/session_1/index_correction.html#functions",
    "href": "tutorials/session_1/index_correction.html#functions",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Functions",
    "text": "Functions\n\n# matlab like syntax\n# with positional and keyword arguments separated by `;`\n\nfunction fun(a,b; c=3)\n    z = a+b*c\n    return z\nend\n\nfun (generic function with 1 method)\n\n\n\nfun(1,2)\n\n7\n\n\n\nfun(1,2; c=4)\n\n9"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Macro II - Fluctuations",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\n\n\n\n\nMar 20, 2024\n\n\nSolving DSGE models\n\n\n\n\nMar 27, 2024\n\n\nSmall Open Economy Extension (IRBC)\n\n\n\n\nApr 3, 2024\n\n\nHeterogenous Agents\n\n\n\n\nApr 10, 2024\n\n\nGreen Transition\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#schedule-wip",
    "href": "index.html#schedule-wip",
    "title": "Macro II - Fluctuations",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\n\n\n\n\nMar 20, 2024\n\n\nSolving DSGE models\n\n\n\n\nMar 27, 2024\n\n\nSmall Open Economy Extension (IRBC)\n\n\n\n\nApr 3, 2024\n\n\nHeterogenous Agents\n\n\n\n\nApr 10, 2024\n\n\nGreen Transition\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "slides/session_2/index.html#why-a-small-open-economy",
    "href": "slides/session_2/index.html#why-a-small-open-economy",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Why a small open economy?",
    "text": "Why a small open economy?\nWhat are the classical reasons to open economy to trade\n\n\ntrade integration\n\ntaste for variety\ncomparative advantage\n\nfinancial integration\n\nsmooth shock / insurance"
  },
  {
    "objectID": "slides/session_2/index.html#from-rbc-to-irbc",
    "href": "slides/session_2/index.html#from-rbc-to-irbc",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "From RBC to IRBC",
    "text": "From RBC to IRBC\nAfter the success of RBC models to match business cycles it didn’t take long before the same methodology was applied to International Business Cycles\n\nSeminal Paper:\n\nInternational Real Business Cycles, Backus, Kehoe, Kydland (1992) (freshwater economists)\n\nVery successful methodology:\n\nfacts at odd with theoretical predictions have been called “puzzles”"
  },
  {
    "objectID": "slides/session_2/index.html#irbc-facts",
    "href": "slides/session_2/index.html#irbc-facts",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "IRBC Facts",
    "text": "IRBC Facts\n\nMomentsFrom Kehoe,Kydland (1995)"
  },
  {
    "objectID": "slides/session_2/index.html#irbc-facts-1",
    "href": "slides/session_2/index.html#irbc-facts-1",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "IRBC Facts",
    "text": "IRBC Facts\n\n\n\n\n\nMoments\n\n\n\n\n\n\nComoments"
  },
  {
    "objectID": "slides/session_2/index.html#stylized-facts",
    "href": "slides/session_2/index.html#stylized-facts",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Stylized Facts",
    "text": "Stylized Facts\n\n\n\n\n\nMoments\n\n\n\n\n\nComoments\n\n\n\n\nDomestically:\n\n\noutput more variable than consumption\noutput autocorrelated\nproductivity strongly procyclical\ntrade balance strongly countercyclcal\npositive comovements in output\n\n\n\nInternationally:\n\nsmaller comovements in consumption\n\nBackus-Kehoe-Kydland puzzle"
  },
  {
    "objectID": "slides/session_2/index.html#endowment-model",
    "href": "slides/session_2/index.html#endowment-model",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Endowment model",
    "text": "Endowment model\nTake an endowment economy: income \\((y_t)_t\\) is exogenously given. We assume it is deterministic\n\\[\\max_{c_t} \\sum_{t=0}^{\\infty} \\beta^t u(c_t)\\]\n\\[c_t+a_{t+1} \\leq y_t + (1+r) a_t\\]\nCountry takes world interest rate \\(r\\) as given\n\na small open economy doesn’t affect world prices"
  },
  {
    "objectID": "slides/session_2/index.html#endowment-model-2",
    "href": "slides/session_2/index.html#endowment-model-2",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Endowment model (2)",
    "text": "Endowment model (2)\nWe solve this problem with the terminal conditions:\n\n\\(a_0\\) given\n\\(\\lim_{T\\rightarrow\\infty} \\frac{a_{T+1}}{(1+r)^T}\\geq0\\)\n\nno-ponzi condition\n\n\n\nThe no-ponzi condition will in effect eliminate diverging solutions. In a first order approximation, it selects the right eigenvalues."
  },
  {
    "objectID": "slides/session_2/index.html#endowment-model-3",
    "href": "slides/session_2/index.html#endowment-model-3",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Endowment model (3)",
    "text": "Endowment model (3)\nWe get the lagrangian:\n\\[\\mathcal{L}= \\sum_{t=0}^{\\infty} \\beta^t u(c_t) + \\sum_{t=0}^{\\infty} \\beta^t \\lambda_t \\left(y_t + (1+r) a_t - c_t-a_{t+1} \\right)\\]\nFirst order conditions:\n\\[\\begin{align}\nu^{\\prime}(c_t)& =& \\lambda_t \\\\\n\\lambda_t &=& \\beta (1+r) \\lambda_{t+1}\n\\end{align}\\]\nUnder the technical assumption \\(\\beta (1+r)=1\\) we get:\n\\[c_0 = \\frac{r}{1+r}\\left\\{ (1+r) a_0 + \\sum_{t=0}^{\\infty} \\frac{y_t}{(1+r)^t}\\right\\}\\]\n\n\nproblem isomorphic to consumption-savings decisions\nconsumption is determined by permanent income"
  },
  {
    "objectID": "slides/session_2/index.html#current-account",
    "href": "slides/session_2/index.html#current-account",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Current Account",
    "text": "Current Account\n\n\n\n\n\n\n\nReminders on Current Account\n\n\nThe trade balance is exports-imports (here \\(y_t-c_t\\))\nThe current account is trade balance + net factor payments (here \\(y_t-c_t+r a_t\\))\nPositive current account: additional lending to the rest of the world.\n\n\n\n\n\nUsing the formula from before\n\\[CA_0 =  a_0 r + (1-\\frac{r}{1+r}) y_0 - \\frac{r}{1+r}\\left\\{ \\sum_{t\\geq1}^{\\infty} \\frac{y_t}{(1+r)^t}\\right\\}\\]\nHow does the current account reacts to income shocks?\n\ncurrent account responds positively to temporary shock in income\nand to news about future income shocks:\n\nThis is the intertemporal approach to the current account"
  },
  {
    "objectID": "slides/session_2/index.html#unit-root",
    "href": "slides/session_2/index.html#unit-root",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Unit root",
    "text": "Unit root\nStill with the same formula: \\[c_0 = \\frac{r}{1+r}\\left\\{ (1+r) a_0 + \\sum_{t=0}^{\\infty} \\frac{y_t}{(1+r)^t}\\right\\}\\]\nWhat is the effect of an increase in \\(a_0\\)?\n\nconsumption rises permanently\n\nby small amount \\(r\\) corresponding to interests paid forever on \\(a_0\\)\n\nthis will correspond to a unit root in the solution"
  },
  {
    "objectID": "slides/session_2/index.html#exercise",
    "href": "slides/session_2/index.html#exercise",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Exercise",
    "text": "Exercise\nFrom the first order conditions\n\\[\\begin{align}\nu^{\\prime}(c_t) & = & \\lambda_t \\\\\n\\lambda_t & = &  \\beta (1+r) \\lambda_{t+1}\n\\end{align}\\]\nassuming \\(u(c_t) = \\log (c_t)\\), can you get the equation for the law of motion of \\(a_t\\) and show the presence of a unit root?"
  },
  {
    "objectID": "slides/session_2/index.html#adding-capital",
    "href": "slides/session_2/index.html#adding-capital",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Adding capital",
    "text": "Adding capital\nWe add capital and production to our endowment economy: \\[y_t = z_t k_t^\\alpha\\] \\[k_t = (1-\\delta) k_{t-1} + i_{t-1}\\]\nThe aggregate resource constraint becomes:\n\\[a_{t+1} + c_t + i_t = (1+r) a_t + y_t\\]\nNow maximize \\(\\sum_t \\beta^ t U(c_t)\\)\n\nWe get first order conditions\n\\[\\lambda_t = \\beta \\lambda_{t+1} (1+r)\\] \\[\\lambda_t = \\beta \\lambda_{t+1}\\left[ (1-\\delta) + z_{t+1} f^{\\prime}(k_{t+1}) \\right]\\]\nwhere \\(\\lambda_t\\) is lagrange multiplier associated to budget constraint."
  },
  {
    "objectID": "slides/session_2/index.html#adding-capital-optimality-conditions",
    "href": "slides/session_2/index.html#adding-capital-optimality-conditions",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Adding capital: optimality conditions",
    "text": "Adding capital: optimality conditions\nSince \\(\\lambda_t\\) (constraint is always binding), we get:\n\\[(1-\\delta) + z_{t+1} f^{\\prime}(k_{t+1}) = 1+r\\]\n\\[k_{t+1} = \\left( \\frac{r+\\delta}{\\alpha z_{t+1}}\\right)^{\\frac{1}{\\alpha-1}}\\]\nand investment \\[i_t = \\left( \\frac{r+\\delta}{\\alpha z_{t+1}}\\right)^{\\frac{1}{\\alpha-1}}- (1-\\delta)\\left( \\frac{r+\\delta}{\\alpha z_{t}}\\right)^{\\frac{1}{\\alpha-1}}\\]\n\nHere investment is fully determined by productivity shocks\n\ntoo simple: no international dependence"
  },
  {
    "objectID": "slides/session_2/index.html#add-friction-to-the-investment",
    "href": "slides/session_2/index.html#add-friction-to-the-investment",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Add friction to the investment",
    "text": "Add friction to the investment\nA possible solution: change the resource constraint such that adjusting capital is costly\nFor instance:\n\\[a_{t+1} + c_t + i_t + \\frac{\\omega}{2}\\frac{(k_{t+1}-k_t)^ 2}{k_t} = (1+r)a_t + z f(k_t)\\]\n\\[k_{t+1} = (1-\\delta) k_t + i_t\\]\nwhere \\(\\omega\\) is an adjustment friction. Typically, \\(\\omega\\) is chosen so that the model replicates \\(\\frac{Var(i_t)}{Var(y_t)}\\) from the data.\n\n🔜 Cf tutorial."
  },
  {
    "objectID": "slides/session_2/index.html#a-benchmark-small-open-economy-model-1",
    "href": "slides/session_2/index.html#a-benchmark-small-open-economy-model-1",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "A benchmark Small Open Economy Model",
    "text": "A benchmark Small Open Economy Model\n\n\n\n\n\nStephanie Schmitt Grohe and Martin Uribe\n\n\n\nClosing Small Economy Models, Schmitt Grohe and Uribe (2003), JIE\n\nsmall open economy model with production, consumption-leisure tradeoff and capital adjustment costs\n\n= RBC+open+adj costs\n\nperform some moments matching\ncompare different ways of stationarizing the model"
  },
  {
    "objectID": "slides/session_2/index.html#the-model",
    "href": "slides/session_2/index.html#the-model",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "The model",
    "text": "The model\n\\[\\max_{c_t, n_t} \\sum_{t=0}^{\\infty} \\beta^t u(c_t)\\]\n\\[c_t + k_{t+1} + a_{t+1} = y_t + g_t - \\frac{\\omega}{2}(k_{t+1}-k_t)^2 +(1-\\delta) k_t + (1+r^{\\star}+\\pi(a_t))a_t\\] \\[y_t = f(k_t, n_t, z_t)\\]\n\\[z_{t+1} = \\rho z_t + \\epsilon_{t+1}\\]\nand \\(u(c, n) = \\frac{1}{1-\\sigma}\\left(c^{\\psi}(1-n)^{1-\\psi}\n)\\right)^{1-\\sigma}\\)"
  },
  {
    "objectID": "slides/session_2/index.html#how-to-make-the-distribution-stationary",
    "href": "slides/session_2/index.html#how-to-make-the-distribution-stationary",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "How to make the distribution stationary?",
    "text": "How to make the distribution stationary?\nThe solution of the model exhibits a unit root:\n\\[a_t = a_{t-1} + ... \\text{other variables in t-1} + \\text{shocks in t}\\]\n\nProblem:\n\nthere isn’t a unique deterministic steady-state\nthe ergodic distribution of the model variables is not defined\n\nThis raises practical issues (notably for estimation) for the linear model.\n\nno unconditional moments"
  },
  {
    "objectID": "slides/session_2/index.html#how-to-get-rid-of-the-unit-root",
    "href": "slides/session_2/index.html#how-to-get-rid-of-the-unit-root",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "How to get rid of the unit root?",
    "text": "How to get rid of the unit root?\nGeneral idea:\n\nintroduce a force that pulls the level of foreign assets towards equilibrium\n\nSchmitt Grohe and Uribe (2003) consider many options:\n\n\n\ndebt-elastic interest rate: \\[1+r = 1+r^{\\star} + \\pi(a_d)\\]\n\nwith \\(\\pi(0)=0\\) and \\(\\pi^{\\prime}(0)&gt;0\\)\n\\(\\pi\\) can be understood as a risk premium on rising debt\n\n\n\n\n\nendogenous time-discount (aka Usawa preferences) \\[\\beta(c_t) = (1+c_t)^{-\\chi}\\]\ncosts of adjustment for international portfolios\n\n\n\n\nSGU show that the choice of the stationarization device has little effect for the dynamics (moments) of most variables"
  },
  {
    "objectID": "slides/session_2/index.html#calibration",
    "href": "slides/session_2/index.html#calibration",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Calibration",
    "text": "Calibration\n\n\n\n\n\nParameters\nValues\n\n\n\n\n\\(σ\\)\n2\n\n\n\\(ψ\\)\n1.45\n\n\n\\(α\\)\n0.32\n\n\n\\(ω\\)\n0.028\n\n\n\\(r\\)\n0.04\n\n\n\n\n\n\n\nParameters\nValues\n\n\n\n\n\\(δ\\)\n0.1\n\n\n\\(ρ\\)\n0.42\n\n\n\\(σ²\\)\n0.0129\n\n\n\\(A^{\\star}\\)\n-0.7442\n\n\n\\(χ\\)\n0.000742"
  },
  {
    "objectID": "slides/session_2/index.html#results",
    "href": "slides/session_2/index.html#results",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Results",
    "text": "Results\n\n\n\nImpulse Response Function"
  },
  {
    "objectID": "slides/session_2/index.html#section",
    "href": "slides/session_2/index.html#section",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "",
    "text": "Moments (from SGU)"
  },
  {
    "objectID": "slides/session_2/index.html#conclusions",
    "href": "slides/session_2/index.html#conclusions",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Conclusions",
    "text": "Conclusions\n\nThe model matches unconditional correlations fairly well\n\nThe stationarization device has little effect on the moments\n\nUnconditional correlations are not that great\n\na limitation of the moment matching method?\n\nCorrelation of consumption with output is too high\n\nand probably cross-correlation of consumption too low\nstill the Backus-Kehoe-Kydland puzzle…"
  },
  {
    "objectID": "slides/session_2/handout.html",
    "href": "slides/session_2/handout.html",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "",
    "text": "What are the classical reasons to open economy to trade\n\n\ntrade integration\n\ntaste for variety\ncomparative advantage\n\nfinancial integration\n\nsmooth shock / insurance\n\n\n\n\n\n\nAfter the success of RBC models to match business cycles it didn’t take long before the same methodology was applied to International Business Cycles\n. . .\nSeminal Paper:\n\nInternational Real Business Cycles, Backus, Kehoe, Kydland (1992) (freshwater economists)\n\nVery successful methodology:\n\nfacts at odd with theoretical predictions have been called “puzzles”\n\n\n\n\n\n\n\nMoments\n\n\nFrom Kehoe,Kydland (1995)\n\n\n\n\n\n\n\n\nMoments\n\n\n\n\n\n\nComoments\n\n\n\n\n\n\n\n\n\n\n\n\nMoments\n\n\n\n\n\nComoments\n\n\n\n\nDomestically:\n\n\noutput more variable than consumption\noutput autocorrelated\nproductivity strongly procyclical\ntrade balance strongly countercyclcal\npositive comovements in output\n\n\n\nInternationally:\n\nsmaller comovements in consumption\n\nBackus-Kehoe-Kydland puzzle",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#why-a-small-open-economy",
    "href": "slides/session_2/handout.html#why-a-small-open-economy",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "",
    "text": "What are the classical reasons to open economy to trade\n\n\ntrade integration\n\ntaste for variety\ncomparative advantage\n\nfinancial integration\n\nsmooth shock / insurance",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#from-rbc-to-irbc",
    "href": "slides/session_2/handout.html#from-rbc-to-irbc",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "",
    "text": "After the success of RBC models to match business cycles it didn’t take long before the same methodology was applied to International Business Cycles\n. . .\nSeminal Paper:\n\nInternational Real Business Cycles, Backus, Kehoe, Kydland (1992) (freshwater economists)\n\nVery successful methodology:\n\nfacts at odd with theoretical predictions have been called “puzzles”",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#irbc-facts",
    "href": "slides/session_2/handout.html#irbc-facts",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "",
    "text": "Moments\n\n\nFrom Kehoe,Kydland (1995)",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#irbc-facts-1",
    "href": "slides/session_2/handout.html#irbc-facts-1",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "",
    "text": "Moments\n\n\n\n\n\n\nComoments",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#stylized-facts",
    "href": "slides/session_2/handout.html#stylized-facts",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "",
    "text": "Moments\n\n\n\n\n\nComoments\n\n\n\n\nDomestically:\n\n\noutput more variable than consumption\noutput autocorrelated\nproductivity strongly procyclical\ntrade balance strongly countercyclcal\npositive comovements in output\n\n\n\nInternationally:\n\nsmaller comovements in consumption\n\nBackus-Kehoe-Kydland puzzle",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#endowment-model",
    "href": "slides/session_2/handout.html#endowment-model",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Endowment model",
    "text": "Endowment model\nTake an endowment economy: income \\((y_t)_t\\) is exogenously given. We assume it is deterministic\n\\[\\max_{c_t} \\sum_{t=0}^{\\infty} \\beta^t u(c_t)\\]\n\\[c_t+a_{t+1} \\leq y_t + (1+r) a_t\\]\nCountry takes world interest rate \\(r\\) as given\n\na small open economy doesn’t affect world prices",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#endowment-model-2",
    "href": "slides/session_2/handout.html#endowment-model-2",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Endowment model (2)",
    "text": "Endowment model (2)\nWe solve this problem with the terminal conditions:\n\n\\(a_0\\) given\n\\(\\lim_{T\\rightarrow\\infty} \\frac{a_{T+1}}{(1+r)^T}\\geq0\\)\n\nno-ponzi condition\n\n\n. . .\nThe no-ponzi condition will in effect eliminate diverging solutions. In a first order approximation, it selects the right eigenvalues.",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#endowment-model-3",
    "href": "slides/session_2/handout.html#endowment-model-3",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Endowment model (3)",
    "text": "Endowment model (3)\nWe get the lagrangian:\n\\[\\mathcal{L}= \\sum_{t=0}^{\\infty} \\beta^t u(c_t) + \\sum_{t=0}^{\\infty} \\beta^t \\lambda_t \\left(y_t + (1+r) a_t - c_t-a_{t+1} \\right)\\]\nFirst order conditions:\n\\[\\begin{align}\nu^{\\prime}(c_t)& =& \\lambda_t \\\\\n\\lambda_t &=& \\beta (1+r) \\lambda_{t+1}\n\\end{align}\\]\nUnder the technical assumption \\(\\beta (1+r)=1\\) we get:\n\\[c_0 = \\frac{r}{1+r}\\left\\{ (1+r) a_0 + \\sum_{t=0}^{\\infty} \\frac{y_t}{(1+r)^t}\\right\\}\\]\n. . .\n\nproblem isomorphic to consumption-savings decisions\nconsumption is determined by permanent income",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#current-account",
    "href": "slides/session_2/handout.html#current-account",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Current Account",
    "text": "Current Account\n\n\n\n\n\n\nReminders on Current Account\n\n\n\nThe trade balance is exports-imports (here \\(y_t-c_t\\))\nThe current account is trade balance + net factor payments (here \\(y_t-c_t+r a_t\\))\nPositive current account: additional lending to the rest of the world.\n\n\n. . .\nUsing the formula from before\n\\[CA_0 =  a_0 r + (1-\\frac{r}{1+r}) y_0 - \\frac{r}{1+r}\\left\\{ \\sum_{t\\geq1}^{\\infty} \\frac{y_t}{(1+r)^t}\\right\\}\\]\nHow does the current account reacts to income shocks?\n\ncurrent account responds positively to temporary shock in income\nand to news about future income shocks:\n\nThis is the intertemporal approach to the current account",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#unit-root",
    "href": "slides/session_2/handout.html#unit-root",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Unit root",
    "text": "Unit root\nStill with the same formula: \\[c_0 = \\frac{r}{1+r}\\left\\{ (1+r) a_0 + \\sum_{t=0}^{\\infty} \\frac{y_t}{(1+r)^t}\\right\\}\\]\nWhat is the effect of an increase in \\(a_0\\)?\n\nconsumption rises permanently\n\nby small amount \\(r\\) corresponding to interests paid forever on \\(a_0\\)\n\nthis will correspond to a unit root in the solution",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#exercise",
    "href": "slides/session_2/handout.html#exercise",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Exercise",
    "text": "Exercise\nFrom the first order conditions\n\\[\\begin{align}\nu^{\\prime}(c_t) & = & \\lambda_t \\\\\n\\lambda_t & = &  \\beta (1+r) \\lambda_{t+1}\n\\end{align}\\]\nassuming \\(u(c_t) = \\log (c_t)\\), can you get the equation for the law of motion of \\(a_t\\) and show the presence of a unit root?",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#adding-capital",
    "href": "slides/session_2/handout.html#adding-capital",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Adding capital",
    "text": "Adding capital\nWe add capital and production to our endowment economy: \\[y_t = z_t k_t^\\alpha\\] \\[k_t = (1-\\delta) k_{t-1} + i_{t-1}\\]\nThe aggregate resource constraint becomes:\n\\[a_{t+1} + c_t + i_t = (1+r) a_t + y_t\\]\nNow maximize \\(\\sum_t \\beta^ t U(c_t)\\)\n. . .\nWe get first order conditions\n\\[\\lambda_t = \\beta \\lambda_{t+1} (1+r)\\] \\[\\lambda_t = \\beta \\lambda_{t+1}\\left[ (1-\\delta) + z_{t+1} f^{\\prime}(k_{t+1}) \\right]\\]\nwhere \\(\\lambda_t\\) is lagrange multiplier associated to budget constraint.",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#adding-capital-optimality-conditions",
    "href": "slides/session_2/handout.html#adding-capital-optimality-conditions",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Adding capital: optimality conditions",
    "text": "Adding capital: optimality conditions\nSince \\(\\lambda_t\\) (constraint is always binding), we get:\n\\[(1-\\delta) + z_{t+1} f^{\\prime}(k_{t+1}) = 1+r\\]\n\\[k_{t+1} = \\left( \\frac{r+\\delta}{\\alpha z_{t+1}}\\right)^{\\frac{1}{\\alpha-1}}\\]\nand investment \\[i_t = \\left( \\frac{r+\\delta}{\\alpha z_{t+1}}\\right)^{\\frac{1}{\\alpha-1}}- (1-\\delta)\\left( \\frac{r+\\delta}{\\alpha z_{t}}\\right)^{\\frac{1}{\\alpha-1}}\\]\n. . .\nHere investment is fully determined by productivity shocks\n\ntoo simple: no international dependence",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#add-friction-to-the-investment",
    "href": "slides/session_2/handout.html#add-friction-to-the-investment",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Add friction to the investment",
    "text": "Add friction to the investment\nA possible solution: change the resource constraint such that adjusting capital is costly\nFor instance:\n\\[a_{t+1} + c_t + i_t + \\frac{\\omega}{2}\\frac{(k_{t+1}-k_t)^ 2}{k_t} = (1+r)a_t + z f(k_t)\\]\n\\[k_{t+1} = (1-\\delta) k_t + i_t\\]\nwhere \\(\\omega\\) is an adjustment friction. Typically, \\(\\omega\\) is chosen so that the model replicates \\(\\frac{Var(i_t)}{Var(y_t)}\\) from the data.\n. . .\n🔜 Cf tutorial.",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#a-benchmark-small-open-economy-model-1",
    "href": "slides/session_2/handout.html#a-benchmark-small-open-economy-model-1",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "A benchmark Small Open Economy Model",
    "text": "A benchmark Small Open Economy Model\n\n\n\n\n\nStephanie Schmitt Grohe and Martin Uribe\n\n\n\nClosing Small Economy Models, Schmitt Grohe and Uribe (2003), JIE\n\nsmall open economy model with production, consumption-leisure tradeoff and capital adjustment costs\n\n= RBC+open+adj costs\n\nperform some moments matching\ncompare different ways of stationarizing the model",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#the-model",
    "href": "slides/session_2/handout.html#the-model",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "The model",
    "text": "The model\n\\[\\max_{c_t, n_t} \\sum_{t=0}^{\\infty} \\beta^t u(c_t)\\]\n\\[c_t + k_{t+1} + a_{t+1} = y_t + g_t - \\frac{\\omega}{2}(k_{t+1}-k_t)^2 +(1-\\delta) k_t + (1+r^{\\star}+\\pi(a_t))a_t\\] \\[y_t = f(k_t, n_t, z_t)\\]\n\\[z_{t+1} = \\rho z_t + \\epsilon_{t+1}\\]\nand \\(u(c, n) = \\frac{1}{1-\\sigma}\\left(c^{\\psi}(1-n)^{1-\\psi}\n)\\right)^{1-\\sigma}\\)",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#how-to-make-the-distribution-stationary",
    "href": "slides/session_2/handout.html#how-to-make-the-distribution-stationary",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "How to make the distribution stationary?",
    "text": "How to make the distribution stationary?\nThe solution of the model exhibits a unit root:\n\\[a_t = a_{t-1} + ... \\text{other variables in t-1} + \\text{shocks in t}\\]\n. . .\nProblem:\n\nthere isn’t a unique deterministic steady-state\nthe ergodic distribution of the model variables is not defined\n\nThis raises practical issues (notably for estimation) for the linear model.\n\nno unconditional moments",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#how-to-get-rid-of-the-unit-root",
    "href": "slides/session_2/handout.html#how-to-get-rid-of-the-unit-root",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "How to get rid of the unit root?",
    "text": "How to get rid of the unit root?\nGeneral idea:\n\nintroduce a force that pulls the level of foreign assets towards equilibrium\n\nSchmitt Grohe and Uribe (2003) consider many options:\n\n\n\ndebt-elastic interest rate: \\[1+r = 1+r^{\\star} + \\pi(a_d)\\]\n\nwith \\(\\pi(0)=0\\) and \\(\\pi^{\\prime}(0)&gt;0\\)\n\\(\\pi\\) can be understood as a risk premium on rising debt\n\n\n\n\n\nendogenous time-discount (aka Usawa preferences) \\[\\beta(c_t) = (1+c_t)^{-\\chi}\\]\ncosts of adjustment for international portfolios\n\n\n\n. . .\nSGU show that the choice of the stationarization device has little effect for the dynamics (moments) of most variables",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#calibration",
    "href": "slides/session_2/handout.html#calibration",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Calibration",
    "text": "Calibration\n\n\n\n\n\nParameters\nValues\n\n\n\n\n\\(σ\\)\n2\n\n\n\\(ψ\\)\n1.45\n\n\n\\(α\\)\n0.32\n\n\n\\(ω\\)\n0.028\n\n\n\\(r\\)\n0.04\n\n\n\n\n\n\n\nParameters\nValues\n\n\n\n\n\\(δ\\)\n0.1\n\n\n\\(ρ\\)\n0.42\n\n\n\\(σ²\\)\n0.0129\n\n\n\\(A^{\\star}\\)\n-0.7442\n\n\n\\(χ\\)\n0.000742",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#results",
    "href": "slides/session_2/handout.html#results",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Results",
    "text": "Results\n\n\n\nImpulse Response Function",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#section",
    "href": "slides/session_2/handout.html#section",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "",
    "text": "Moments (from SGU)",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/session_2/handout.html#conclusions",
    "href": "slides/session_2/handout.html#conclusions",
    "title": "Small Open Economy Extension (IRBC)",
    "section": "Conclusions",
    "text": "Conclusions\n\nThe model matches unconditional correlations fairly well\n\nThe stationarization device has little effect on the moments\n\nUnconditional correlations are not that great\n\na limitation of the moment matching method?\n\nCorrelation of consumption with output is too high\n\nand probably cross-correlation of consumption too low\nstill the Backus-Kehoe-Kydland puzzle…",
    "crumbs": [
      "lectures",
      "Small Open Economy Extension (IRBC)"
    ]
  },
  {
    "objectID": "slides/prep_4/index_handout.html",
    "href": "slides/prep_4/index_handout.html",
    "title": "Green Transition",
    "section": "",
    "text": "Come back later!."
  },
  {
    "objectID": "slides/session_1/handout.html",
    "href": "slides/session_1/handout.html",
    "title": "Solving DSGE models",
    "section": "",
    "text": "What is the main specificity of economic modeling?\n\nIn (macro)economics, we model the behaviour of economic agents by specifying:\n\ntheir objective \\[\\max_{c_t} E_t \\sum_{s\\geq t} \\beta^s U(c_s)\\] \\[\\max \\pi_t\\] \\[\\cdots\\]\ntheir constraints (budget constraint, econ. environment…)\n\n\n\n\n\n\n. . .\n\nThis has important implications:\n\nmacro models are forward looking\nmacro models need to be solved\n\n\n\nIn many cases, there is not closed form for the solution -&gt; we need numerical techniques\n\n\n\n\n\n\n\n\n1996: Michel Juillard created an opensource software to solve DSGE models\n\nDSGE: Dynamic Stochastic General Equilibrium\nusually solved around a steady-state\n\nNow about 10 contributors.\n\n\n\n\nIt has been widely adopted:\n\nearly version in Gauss\nthen Matlab/Octave/Scilab\nlatest version in Julia\n\n\n\n\n\n\n\nMichel Juillard\n\n\n\n\n\n\n\nNowadays most DSGE models built in institutions have a Dynare version (IMF/GIMF, EC/Quest, ECB/, NYFed/FRBNY)\n\nthey are usually based on the midsize model from Smets & Wouters (10 equations)\nbut have grown up a lot (&gt;&gt;100 equations)\n\n. . .\nInstitutions (led by researchers) are (slowly) diversifying their model\n\nComputational General Equilibrium Models\nAgent-based\nSemi-structural models\nHeterogenous Agents Models",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#section",
    "href": "slides/session_1/handout.html#section",
    "title": "Solving DSGE models",
    "section": "",
    "text": "What is the main specificity of economic modeling?\n\nIn (macro)economics, we model the behaviour of economic agents by specifying:\n\ntheir objective \\[\\max_{c_t} E_t \\sum_{s\\geq t} \\beta^s U(c_s)\\] \\[\\max \\pi_t\\] \\[\\cdots\\]\ntheir constraints (budget constraint, econ. environment…)\n\n\n\n\n\n\n. . .\n\nThis has important implications:\n\nmacro models are forward looking\nmacro models need to be solved\n\n\n\nIn many cases, there is not closed form for the solution -&gt; we need numerical techniques",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#dynare",
    "href": "slides/session_1/handout.html#dynare",
    "title": "Solving DSGE models",
    "section": "",
    "text": "1996: Michel Juillard created an opensource software to solve DSGE models\n\nDSGE: Dynamic Stochastic General Equilibrium\nusually solved around a steady-state\n\nNow about 10 contributors.\n\n\n\n\nIt has been widely adopted:\n\nearly version in Gauss\nthen Matlab/Octave/Scilab\nlatest version in Julia\n\n\n\n\n\n\n\nMichel Juillard",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#dsge-models-in-institutions",
    "href": "slides/session_1/handout.html#dsge-models-in-institutions",
    "title": "Solving DSGE models",
    "section": "",
    "text": "Nowadays most DSGE models built in institutions have a Dynare version (IMF/GIMF, EC/Quest, ECB/, NYFed/FRBNY)\n\nthey are usually based on the midsize model from Smets & Wouters (10 equations)\nbut have grown up a lot (&gt;&gt;100 equations)\n\n. . .\nInstitutions (led by researchers) are (slowly) diversifying their model\n\nComputational General Equilibrium Models\nAgent-based\nSemi-structural models\nHeterogenous Agents Models",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#model",
    "href": "slides/session_1/handout.html#model",
    "title": "Solving DSGE models",
    "section": "Model",
    "text": "Model\nA very concise representation of a model\n\\[\\mathbb{E}_t \\left[ f(y_{t+1}, y_t, y_{t-1}, \\epsilon_t) \\right]= 0\\]\n\n\n\nThe problem:\n\n\\(y_t\\in\\mathbb{R}^n\\): the vector of endogenous variables\n\\(\\epsilon_t\\in\\mathbb{R}^{n_e}\\): the vector of exogenous variables\n\nwe assume that \\(\\epsilon_t\\) is a zero-mean gaussian process\n\n\\(f: \\mathbb{R}^n\\rightarrow \\mathbb{R}^n\\): the model equations\n\n\n\n\nThe solution:\n\n\\(g\\) such that \\[\\forall t, y_t = g(y_{t-1},\\epsilon_t)\\]\n\n\n\n\n\nThe situation is different when one is making a perfect foresight simulation.",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#the-timing-of-the-equations",
    "href": "slides/session_1/handout.html#the-timing-of-the-equations",
    "title": "Solving DSGE models",
    "section": "The timing of the equations",
    "text": "The timing of the equations\n\n\n\n\n\n\nTip\n\n\n\nIn dynare the model equations are coded in the model; ... ; end; block.\n\n\nNew information arrives with the innovations \\(\\epsilon_t\\).\nAt date \\(t\\), the information set is spanned by \\(\\mathcal{F}_t = \\mathcal{F} (\\cdots, \\epsilon_{t-3}, \\epsilon_{t-2}, \\epsilon_{t-1}, \\epsilon_t)\\)\nBy convention an endogenous variable has a subscript \\(t\\) if it is known first at date \\(t\\).",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#example",
    "href": "slides/session_1/handout.html#example",
    "title": "Solving DSGE models",
    "section": "Example",
    "text": "Example\nThe timing of equations\nUsing Dynare’s timing conventions:\n\nWrite the production function in the RBC\nWrite the law of motion for capital \\(k\\), with a depreciation rate \\(\\delta\\) and investment \\(i\\)\n\nwhen is capital known?\nwhen is investment known?\n\nAdd a multiplicative investment efficiency shock \\(\\chi_t\\). Assume it is an \\(AR1\\) driven by innovation \\(\\eta_t\\) and autocorrelation \\(\\rho_{\\chi}\\)",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#steady-state",
    "href": "slides/session_1/handout.html#steady-state",
    "title": "Solving DSGE models",
    "section": "Steady-state",
    "text": "Steady-state\nThe deterministic steady-state satisfies:\n\\[ f(\\overline{y},\\overline{y}, \\overline{y}, 0)= 0\\]\nOften, there is a closed-form solution.\nOtherwise, one must resort to a numerical solver to solve\n\\[\\overline{y}\\rightarrow f(\\overline{y},\\overline{y}, \\overline{y}, 0)\\]\n\n\n\n\n\n\nTip\n\n\n\n\n\nIn dynare the steady-state values are provided in the steadystate_model; ... ; end; block. One can check they are correct using the check; statement.\nTo find numerically the steady-state: steady;.",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#the-implicit-system",
    "href": "slides/session_1/handout.html#the-implicit-system",
    "title": "Solving DSGE models",
    "section": "The implicit system",
    "text": "The implicit system\nReplacing the solution \\[y_t = g(y_{t-1},\\epsilon_t)\\] in the system \\[\\mathbb{E}_t \\left[ f(y_{t+1}, y_t, y_{t-1}, \\epsilon_t) \\right]= 0\\]\nwe obtain:\n\\[\\mathbb{E}_t \\left[ f(g(g(y_{t-1},\\epsilon_{t}),\\epsilon_{t+1}), g(y_{t-1},\\epsilon_t), y_{t-1}, \\epsilon_t) \\right]= 0\\]\nIt is an equation defining implicitly the function \\(g()\\)",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#the-state-space",
    "href": "slides/session_1/handout.html#the-state-space",
    "title": "Solving DSGE models",
    "section": "The state-space",
    "text": "The state-space\n\\[\\mathbb{E}_t \\left[ f(g(g(y_{t-1},\\epsilon_{t}),\\epsilon_{t+1}), g(y_{t-1},\\epsilon_t), y_{t-1}, \\epsilon_t) \\right]= 0\\]\nIn this expression, \\(y_{t-1},\\epsilon_t\\) is the state-space.\n. . .\nDropping the time subscripts, the equation must be satisfied for any realization of \\((y,\\epsilon)\\) \\[\\forall (y,\\epsilon)\\  \\Phi(g)(y,\\epsilon) = \\mathbb{E}_{\\epsilon'} \\left[ f(g(g(y,\\epsilon),\\epsilon'), g(y,\\epsilon), y, \\epsilon) \\right]= 0\\]\nIt is a functional equation \\(\\Phi(g)=0\\)",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#expected-shocks",
    "href": "slides/session_1/handout.html#expected-shocks",
    "title": "Solving DSGE models",
    "section": "Expected shocks",
    "text": "Expected shocks\nFirst order approximation:\n\nAssume \\(|y_t-\\overline{y}|&lt;&lt;1\\),\\(|\\epsilon|&lt;&lt;1\\),\\(|\\epsilon'|&lt;&lt;1\\)\n\nPerform a Taylor expansion with respect to future shock:\n\\[\\begin{align}\n& & \\mathbb{E}_{\\epsilon'} \\left[ f(g(g(y,\\epsilon),\\epsilon'), g(y,\\epsilon), y, \\epsilon) \\right]  \\\\\n= & &  \\mathbb{E}_{\\epsilon'}\\left[ f(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon) \\right] \\\\\n  & & +  \\mathbb{E}_{\\epsilon'} \\left[ f^{\\prime}_{y_{t+1}}(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon) g^{\\prime}_{\\epsilon} \\epsilon^\\prime\\right] + o(\\epsilon^{\\prime}) \\\\\n\\approx & & f(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon)\n\\end{align}\\]\n. . .\nThis uses the fact that \\(\\mathbb{E}\\left[ \\epsilon^{\\prime}\\right] = 0\\).\nAt first order, expected shocks play no role.\nTo capture precautionary behaviour (like risk premia), we would need to increase the approximation order.",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#first-order-perturbation",
    "href": "slides/session_1/handout.html#first-order-perturbation",
    "title": "Solving DSGE models",
    "section": "First order perturbation",
    "text": "First order perturbation\nWe are left with the system:\n\\[F(y,\\epsilon) = f(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon) = 0\\]\nWe can now use a variant of the implicit function theorem to recover a first approximation of \\(g\\) as: \\[g(y,\\epsilon) = \\overline{y} + g^{\\prime}_{y} (y-\\overline{y}) + g^{\\prime}_e \\epsilon_t \\]\n. . .\nWe can obtain the unknown quantities \\(g^{\\prime}_y\\), and \\(g^{\\prime}_e\\) using the method of undeterminate coefficients:\nPlug the first approximation into the system and write the conditions \\[F^{\\prime}_y(\\overline{y}, 0) = 0\\] \\[F^{\\prime}_\\epsilon(\\overline{y}, 0) = 0\\]",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#computing-gprime_y",
    "href": "slides/session_1/handout.html#computing-gprime_y",
    "title": "Solving DSGE models",
    "section": "Computing \\(g^{\\prime}_y\\)",
    "text": "Computing \\(g^{\\prime}_y\\)\nRecall the system: \\[F(y,\\epsilon) = f(g(g(y,0),\\epsilon), g(y,\\epsilon), y, \\epsilon) = 0\\]\nWe have \\[F^{\\prime}_y(\\overline{y}, 0) = f^{\\prime}_{y_{t+1}} g^{\\prime}_y g^{\\prime}_y + f^{\\prime}_{y_{t}} g^{\\prime}_y + f^{\\prime}_{y_{t-1}} = 0 \\]\n. . .\nThis is a specific Riccatti equation \\[A X^2 + B X + C\\] where \\(A,B,C\\) and \\(X=g^{\\prime}_y\\) are square matrices \\(\\in \\mathbb{R}^n \\times \\mathbb{R}^n\\)",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#first-order-deterministic-model",
    "href": "slides/session_1/handout.html#first-order-deterministic-model",
    "title": "Solving DSGE models",
    "section": "First Order Deterministic Model",
    "text": "First Order Deterministic Model\nLet’s pause a minute to observe the first order deterministic model: \\[A X^2 + B X + C\\]\nFrom our intuition in dimension 1, we know there must be multiple solutions\n\nhow do we find them?\nhow do we select the right ones?\n\nI the absence of shocks the dynamics of the model are given by \\[y_t = X y_{t-1}\\]\nWhat is the condition for the model to be stationary?\n. . .\n-&gt; the biggest eigenvalue of \\(X\\) should be smaller than 1\n\nDevelop intuition in dimension 1.",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#multiplicity-of-solution",
    "href": "slides/session_1/handout.html#multiplicity-of-solution",
    "title": "Solving DSGE models",
    "section": "Multiplicity of solution",
    "text": "Multiplicity of solution\nIt is possible to show that the system is associated with \\(2 n\\) generalized eigenvalues:\n\\[|\\lambda_1| \\leq \\cdots \\leq |\\lambda_{2 n}|\\]\nFor each choice \\(C\\) of \\(n\\) eigenvalues (\\(|C|=n\\)), a specific recursive solution \\(X_C\\) can be constructed. It has eigenvalues \\(C\\).\n. . .\nThis yields at least \\(\\left(\\begin{matrix} 2 n \\\\ n \\end{matrix}\\right)\\) different combinations.\n. . .\nA model is well defined when there is exactly one solution that is non divergent.\nThis is equivalent to:\n\\[|\\lambda_1| \\leq \\cdots \\leq |\\lambda_{n}| \\leq 1 &lt; |\\lambda_{n+1}| \\leq \\cdots \\leq |\\lambda_{2 n}|\\]",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#example-1",
    "href": "slides/session_1/handout.html#example-1",
    "title": "Solving DSGE models",
    "section": "Example 1",
    "text": "Example 1\nForward looking inflation:\n\\[\\pi_t = \\alpha \\pi_{t+1}\\] with \\(\\alpha&lt;1\\).\nIs it well defined?\n. . .\nWe can rewrite the system as:\n\\[\\alpha \\pi_{t+1} - \\pi_t + 0 \\pi_{t-1}  = 0\\]\nor\n\\[\\pi_{t+1} - (\\frac{1}{\\alpha} + 0 )\\pi_t + \\left(\\frac{1}{\\alpha} 0\\right) \\pi_{t-1} = 0\\]\n. . .\nThe generalized eigenvalues are \\(0\\leq 1 &lt; \\frac{1}{\\alpha}\\).\n. . .\nThe unique stable solution is \\(\\pi_t=0 \\pi_{t-1}\\)",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#example-2",
    "href": "slides/session_1/handout.html#example-2",
    "title": "Solving DSGE models",
    "section": "Example 2",
    "text": "Example 2\nDebt accumulation equation by a rational agent:\n\\[b_{t+1} - (1+\\frac{1}{\\beta}) b_t + \\frac{1}{\\beta} b_{t-1} = 0\\]\nIs it well-defined?\n. . .\nTwo generalized eigenvalues \\(\\lambda_1=1 &lt; \\lambda_2=\\frac{1}{\\beta}\\)\n. . .\nThe unique non-diverging solution is \\(b_t = b_{t-1}\\).\n\nit is a unit-root: any initial deviation in \\(b_{t-1}\\) has persistent effects",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#example-3",
    "href": "slides/session_1/handout.html#example-3",
    "title": "Solving DSGE models",
    "section": "Example 3",
    "text": "Example 3\nProductivity process: \\[z_t = \\rho z_{t-1}\\] with \\(\\rho&lt;1\\): well defined\n. . .\nIn that case there is a hidden infinite eigenvalue \\(\\infty\\) associated to \\(z_{t+1}\\).\n. . .\nTo see why consider the system associated with eigenvalues \\(m\\) and \\(\\rho\\): \\[z_{t+1} - (m+\\rho) z_t + m \\rho z_{t-1} = 0\\]\n\\[\\frac{1}{m} z_{t+1} - (1+\\frac{\\rho}{m}) z_t + \\rho z_{t-1} = 0\\]\nWhich corresponds to the initial model when \\(m=\\infty\\)\n. . .\nThe generalized eigenvalues are \\(\\lambda_1 = \\rho \\leq 1 &lt; \\lambda_2 = \\infty\\)\nMore generally, any variable that does not appear in \\(t+1\\) creates one infinite generalized eigenvalue.",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#a-criterium-for-well-definedness",
    "href": "slides/session_1/handout.html#a-criterium-for-well-definedness",
    "title": "Solving DSGE models",
    "section": "A criterium for well-definedness",
    "text": "A criterium for well-definedness\nLooking again at the list of eigenvalues we set aside the infinite ones.\nThe model is well specified iff we can sort the eigenvalues as:\n\\[|\\lambda_1| \\leq \\cdots \\leq |\\lambda_{n}| \\leq 1 &lt; |\\lambda_{n+1}| \\leq \\cdots  |\\lambda_{n+k}| \\leq \\underbrace{|\\lambda_{n+k+1}| \\cdots \\leq |\\lambda_{2 n}|}_{\\text{infinite eigenvalues}}\\]\n\n\n\n\n\n\nBlanchard-Kahn criterium\n\n\n\nThe model satisfies the Blanchard-Kahn criterium if the number of eigenvalues greater than one, is exactly equal to the number of variables appearing in \\(t+1\\).\nIn that case the model is well-defined.",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#computing-the-solution",
    "href": "slides/session_1/handout.html#computing-the-solution",
    "title": "Solving DSGE models",
    "section": "Computing the solution",
    "text": "Computing the solution\nThere are several classical methods to compute the solution to the algebraic Riccatti equation: \\[A X^2+ B X + C=0\\]\n\nqz decomposition\n\ntraditionnally used in the DSGE literature since Chris Sims\na little bit unintuitive\n\ncyclic reduction\n\nnew default in dynare, more adequate for big models\n\nlinear time iteration cf @sec:linear_time_iteration\n\nconceptually very simple",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#computing-gprime_e",
    "href": "slides/session_1/handout.html#computing-gprime_e",
    "title": "Solving DSGE models",
    "section": "Computing \\(g^{\\prime}_{e}\\)",
    "text": "Computing \\(g^{\\prime}_{e}\\)\nNow we have \\(g^{\\prime}_y\\), how do we get \\(g^{\\prime}_{e}\\)?\nRecall: \\[F(y,\\epsilon) = f(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon) = 0\\]\nWe have \\[F^{\\prime}_e(\\overline{y}, 0) =  f^{\\prime}_{y_{t+1}}  g^{\\prime}_y  g^{\\prime}_e + f^{\\prime}_{y_{t}} g^{\\prime}_e + f^{\\prime}_{\\epsilon_t} = 0 \\]\nNow this is easy:\n\\[g^{\\prime}_e = - (f^{\\prime}_{y_{t+1}}  g^{\\prime}_y + f^{\\prime}_{y_{t}} )^{-1}  f^{\\prime}_{\\epsilon_t} = 0 \\]",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#the-model-solution",
    "href": "slides/session_1/handout.html#the-model-solution",
    "title": "Solving DSGE models",
    "section": "The model solution",
    "text": "The model solution\nThe result of the model solution: \\[y_t = g_y y_{t-1} + g_e \\epsilon_t\\]\nIt is an AR1, driven by exogenous shock \\(\\epsilon_t\\).\n. . .\nBecause it is a well known structure, one can investigate the model with\n\nimpulse response functions\nstochastic simulations\n\n. . .\nThen to compare the model to the data we compute\n\nimplied moments:\n\ncovariances, autocorrelation\n\nlikelihood\n\nOptimizing the fit to the data is called model estimation",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#what-can-you-do-with-the-solution",
    "href": "slides/session_1/handout.html#what-can-you-do-with-the-solution",
    "title": "Solving DSGE models",
    "section": "What can you do with the solution",
    "text": "What can you do with the solution\nThe solution of a model found by Dynare has an especially simple form: an AR1\n\n\\(y_t = X y_{t-1} + Y \\epsilon_t\\)\nwhere the covariances \\(\\Sigma\\) of \\(\\epsilon_t\\) can be chosen by the modeler\n\n. . .\nWith this solution we can (cf next TD)\n\ncompute (conditional and unconditional) moments\nperform stochastic simulations, impulse response function\n\n. . .",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#going-further",
    "href": "slides/session_1/handout.html#going-further",
    "title": "Solving DSGE models",
    "section": "Going Further",
    "text": "Going Further\nTaking the model to the data with Dynare\n\n“estimate” the model: compute the likelihood of a solution and maximize it by choosing the right parameters\n“identify” shocks in the data\n\nOther functions\n\nhigher order approximation\n(noninear) perfect foresight simulations\nramsey plan\ndiscretionary policy\n…",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#coming-next",
    "href": "slides/session_1/handout.html#coming-next",
    "title": "Solving DSGE models",
    "section": "Coming Next",
    "text": "Coming Next\n\nMany models",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#linear-time-iteration",
    "href": "slides/session_1/handout.html#linear-time-iteration",
    "title": "Solving DSGE models",
    "section": "Linear Time Iteration",
    "text": "Linear Time Iteration\nRecall the system to solve: \\[F(y,\\epsilon) = f(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon) = 0\\]\nbut now assume the decision rules today and tomorrow are different:\n\ntoday: \\(y_t = g(y_{t-1}, \\epsilon_t) = \\overline{y} + X y_{t-1} + g_y \\epsilon_t\\)\ntomorrow: \\(y_{t+1} = \\tilde{g}(y_t, \\epsilon_{t+1}) = \\overline{y} + \\tilde{X} y_{t-1} + \\tilde{g}_y \\epsilon_t\\)\n\nThen the Ricatti equation is written:\n\\[A \\tilde{X} X + B X + C = 0\\]",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#linear-time-iteration-2",
    "href": "slides/session_1/handout.html#linear-time-iteration-2",
    "title": "Solving DSGE models",
    "section": "Linear Time Iteration (2)",
    "text": "Linear Time Iteration (2)\nThe linear time iteration algorithm consists in solving the decision rule \\(X\\) today as a function of decision rule tomorrow \\(\\tilde{X}\\).\nThis corresponds to the simple formula:\n\\[X = -(A\\tilde{X} + B)^{-1} C\\]\nAnd the full algorithm can be described as:\n\nchoose \\(X_0\\)\nfor any \\(X_n\\), compute \\(X_{n+1} = T(X_n) = -(A X_n + B)^{-1} C\\)\n\nrepeat until convergence",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#linear-time-iteration-3",
    "href": "slides/session_1/handout.html#linear-time-iteration-3",
    "title": "Solving DSGE models",
    "section": "Linear Time Iteration (3)",
    "text": "Linear Time Iteration (3)\nIt can be shown that, starting from a random initial guess, the linear time-iteration algorithm converges to the solution \\(X\\) with the smallest modulus:\n\\[\\underbrace{|\\lambda_1| \\leq \\cdots  \\leq |\\lambda_n|}_{\\text{Selected eigenvalues}} \\leq |\\lambda_{n+1}|\\cdots \\leq |\\lambda_{2n}|\\]\nIn other words, it finds the right solution when the model is well specified.\nHow do you check it is well specified?\n\n\\(\\lambda_n\\) is the biggest eigenvalue of solution \\(X\\)\nwhat about \\(\\lambda_{n+1}\\)?\n\n\\(\\frac{1}{\\lambda_{n+1}}\\) is the biggest eigenvalue of \\((AX+B)^{-1}A\\)",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#linear-time-iteration-4",
    "href": "slides/session_1/handout.html#linear-time-iteration-4",
    "title": "Solving DSGE models",
    "section": "Linear Time Iteration (4)",
    "text": "Linear Time Iteration (4)\nDefine \\[M(\\lambda) = A\\lambda^2 + B \\lambda + C\\]\nFor any solution \\(X\\), \\(M(\\lambda)\\) can be factorized as: 1\n\\[M(\\lambda)=(\\lambda A + A X + B)(\\lambda I -X)\\]\nand\n\\[det(M(\\lambda)) = \\underbrace{det(\\lambda A + A X + B)}_{Q(\\lambda)}det(\\lambda I -X)\\]\nBy construction \\(Q(\\lambda)\\) is a polynomial whose roots are those that are not selected by the solution i.e. \\(\\Lambda\\setminus Sp(X)\\).",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#linear-time-iteration-5",
    "href": "slides/session_1/handout.html#linear-time-iteration-5",
    "title": "Solving DSGE models",
    "section": "Linear Time Iteration (5)",
    "text": "Linear Time Iteration (5)\nFor \\(\\lambda \\neq 0\\) we have:\n\\[\\lambda \\in Sp((A X +B )^{-1} A)\\] \\[\\iff  det( (A X +B )^{-1})A - I\\lambda )=0\\] \\[\\iff  det( \\frac{1}{\\lambda} A - I (A X +B )  )=0\\] \\[\\iff Q(\\frac{1}{\\lambda})=0\\] \\[\\iff \\frac{1}{\\lambda} \\in G \\setminus Sp(X)\\]\nIn words, \\((AX+B)^{-1}\\) contains all the eigenvalues that have been rejected by the selection of \\(X\\).\nIn particular, \\(\\rho((AX+B)^{-1})A)=1/\\min(G\\setminus Sp(X))\\)",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/handout.html#footnotes",
    "href": "slides/session_1/handout.html#footnotes",
    "title": "Solving DSGE models",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSpecial case of Bezout theorem. Easy to check in that case↩︎",
    "crumbs": [
      "lectures",
      "Solving DSGE models"
    ]
  },
  {
    "objectID": "slides/session_1/index.html#section",
    "href": "slides/session_1/index.html#section",
    "title": "Solving DSGE models",
    "section": "",
    "text": "What is the main specificity of economic modeling?\n\nIn (macro)economics, we model the behaviour of economic agents by specifying:\n\ntheir objective \\[\\max_{c_t} E_t \\sum_{s\\geq t} \\beta^s U(c_s)\\] \\[\\max \\pi_t\\] \\[\\cdots\\]\ntheir constraints (budget constraint, econ. environment…)\n\n\n\n\n\n\n\n\nThis has important implications:\n\nmacro models are forward looking\nmacro models need to be solved\n\n\n\nIn many cases, there is not closed form for the solution -&gt; we need numerical techniques"
  },
  {
    "objectID": "slides/session_1/index.html#dynare",
    "href": "slides/session_1/index.html#dynare",
    "title": "Solving DSGE models",
    "section": "Dynare",
    "text": "Dynare\n\n\n\n\n1996: Michel Juillard created an opensource software to solve DSGE models\n\nDSGE: Dynamic Stochastic General Equilibrium\nusually solved around a steady-state\n\nNow about 10 contributors.\n\n\n\n\nIt has been widely adopted:\n\nearly version in Gauss\nthen Matlab/Octave/Scilab\nlatest version in Julia\n\n\n\n\n\n\n\nMichel Juillard"
  },
  {
    "objectID": "slides/session_1/index.html#dsge-models-in-institutions",
    "href": "slides/session_1/index.html#dsge-models-in-institutions",
    "title": "Solving DSGE models",
    "section": "DSGE Models in institutions",
    "text": "DSGE Models in institutions\nNowadays most DSGE models built in institutions have a Dynare version (IMF/GIMF, EC/Quest, ECB/, NYFed/FRBNY)\n\nthey are usually based on the midsize model from Smets & Wouters (10 equations)\nbut have grown up a lot (&gt;&gt;100 equations)\n\n\nInstitutions (led by researchers) are (slowly) diversifying their model\n\nComputational General Equilibrium Models\nAgent-based\nSemi-structural models\nHeterogenous Agents Models"
  },
  {
    "objectID": "slides/session_1/index.html#model",
    "href": "slides/session_1/index.html#model",
    "title": "Solving DSGE models",
    "section": "Model",
    "text": "Model\nA very concise representation of a model\n\\[\\mathbb{E}_t \\left[ f(y_{t+1}, y_t, y_{t-1}, \\epsilon_t) \\right]= 0\\]\n\n\n\nThe problem:\n\n\\(y_t\\in\\mathbb{R}^n\\): the vector of endogenous variables\n\\(\\epsilon_t\\in\\mathbb{R}^{n_e}\\): the vector of exogenous variables\n\nwe assume that \\(\\epsilon_t\\) is a zero-mean gaussian process\n\n\\(f: \\mathbb{R}^n\\rightarrow \\mathbb{R}^n\\): the model equations\n\n\n\n\nThe solution:\n\n\\(g\\) such that \\[\\forall t, y_t = g(y_{t-1},\\epsilon_t)\\]\n\n\n\n\n\nThe situation is different when one is making a perfect foresight simulation."
  },
  {
    "objectID": "slides/session_1/index.html#the-timing-of-the-equations",
    "href": "slides/session_1/index.html#the-timing-of-the-equations",
    "title": "Solving DSGE models",
    "section": "The timing of the equations",
    "text": "The timing of the equations\n\n\n\n\n\n\nTip\n\n\nIn dynare the model equations are coded in the model; ... ; end; block.\n\n\n\nNew information arrives with the innovations \\(\\epsilon_t\\).\nAt date \\(t\\), the information set is spanned by \\(\\mathcal{F}_t = \\mathcal{F} (\\cdots, \\epsilon_{t-3}, \\epsilon_{t-2}, \\epsilon_{t-1}, \\epsilon_t)\\)\nBy convention an endogenous variable has a subscript \\(t\\) if it is known first at date \\(t\\)."
  },
  {
    "objectID": "slides/session_1/index.html#example",
    "href": "slides/session_1/index.html#example",
    "title": "Solving DSGE models",
    "section": "Example",
    "text": "Example\nThe timing of equations\nUsing Dynare’s timing conventions:\n\nWrite the production function in the RBC\nWrite the law of motion for capital \\(k\\), with a depreciation rate \\(\\delta\\) and investment \\(i\\)\n\nwhen is capital known?\nwhen is investment known?\n\nAdd a multiplicative investment efficiency shock \\(\\chi_t\\). Assume it is an \\(AR1\\) driven by innovation \\(\\eta_t\\) and autocorrelation \\(\\rho_{\\chi}\\)"
  },
  {
    "objectID": "slides/session_1/index.html#steady-state",
    "href": "slides/session_1/index.html#steady-state",
    "title": "Solving DSGE models",
    "section": "Steady-state",
    "text": "Steady-state\nThe deterministic steady-state satisfies:\n\\[ f(\\overline{y},\\overline{y}, \\overline{y}, 0)= 0\\]\nOften, there is a closed-form solution.\nOtherwise, one must resort to a numerical solver to solve\n\\[\\overline{y}\\rightarrow f(\\overline{y},\\overline{y}, \\overline{y}, 0)\\]\n\n\n\n\n\n\nTip\n\n\nIn dynare the steady-state values are provided in the steadystate_model; ... ; end; block. One can check they are correct using the check; statement.\nTo find numerically the steady-state: steady;."
  },
  {
    "objectID": "slides/session_1/index.html#the-implicit-system",
    "href": "slides/session_1/index.html#the-implicit-system",
    "title": "Solving DSGE models",
    "section": "The implicit system",
    "text": "The implicit system\nReplacing the solution \\[y_t = g(y_{t-1},\\epsilon_t)\\] in the system \\[\\mathbb{E}_t \\left[ f(y_{t+1}, y_t, y_{t-1}, \\epsilon_t) \\right]= 0\\]\nwe obtain:\n\\[\\mathbb{E}_t \\left[ f(g(g(y_{t-1},\\epsilon_{t}),\\epsilon_{t+1}), g(y_{t-1},\\epsilon_t), y_{t-1}, \\epsilon_t) \\right]= 0\\]\nIt is an equation defining implicitly the function \\(g()\\)"
  },
  {
    "objectID": "slides/session_1/index.html#the-state-space",
    "href": "slides/session_1/index.html#the-state-space",
    "title": "Solving DSGE models",
    "section": "The state-space",
    "text": "The state-space\n\\[\\mathbb{E}_t \\left[ f(g(g(y_{t-1},\\epsilon_{t}),\\epsilon_{t+1}), g(y_{t-1},\\epsilon_t), y_{t-1}, \\epsilon_t) \\right]= 0\\]\nIn this expression, \\(y_{t-1},\\epsilon_t\\) is the state-space.\n\nDropping the time subscripts, the equation must be satisfied for any realization of \\((y,\\epsilon)\\) \\[\\forall (y,\\epsilon)\\  \\Phi(g)(y,\\epsilon) = \\mathbb{E}_{\\epsilon'} \\left[ f(g(g(y,\\epsilon),\\epsilon'), g(y,\\epsilon), y, \\epsilon) \\right]= 0\\]\nIt is a functional equation \\(\\Phi(g)=0\\)"
  },
  {
    "objectID": "slides/session_1/index.html#expected-shocks",
    "href": "slides/session_1/index.html#expected-shocks",
    "title": "Solving DSGE models",
    "section": "Expected shocks",
    "text": "Expected shocks\nFirst order approximation:\n\nAssume \\(|y_t-\\overline{y}|&lt;&lt;1\\),\\(|\\epsilon|&lt;&lt;1\\),\\(|\\epsilon'|&lt;&lt;1\\)\n\nPerform a Taylor expansion with respect to future shock:\n\\[\\begin{align}\n& & \\mathbb{E}_{\\epsilon'} \\left[ f(g(g(y,\\epsilon),\\epsilon'), g(y,\\epsilon), y, \\epsilon) \\right]  \\\\\n= & &  \\mathbb{E}_{\\epsilon'}\\left[ f(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon) \\right] \\\\\n  & & +  \\mathbb{E}_{\\epsilon'} \\left[ f^{\\prime}_{y_{t+1}}(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon) g^{\\prime}_{\\epsilon} \\epsilon^\\prime\\right] + o(\\epsilon^{\\prime}) \\\\\n\\approx & & f(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon)\n\\end{align}\\]\n\nThis uses the fact that \\(\\mathbb{E}\\left[ \\epsilon^{\\prime}\\right] = 0\\).\nAt first order, expected shocks play no role.\nTo capture precautionary behaviour (like risk premia), we would need to increase the approximation order."
  },
  {
    "objectID": "slides/session_1/index.html#first-order-perturbation",
    "href": "slides/session_1/index.html#first-order-perturbation",
    "title": "Solving DSGE models",
    "section": "First order perturbation",
    "text": "First order perturbation\nWe are left with the system:\n\\[F(y,\\epsilon) = f(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon) = 0\\]\nWe can now use a variant of the implicit function theorem to recover a first approximation of \\(g\\) as: \\[g(y,\\epsilon) = \\overline{y} + g^{\\prime}_{y} (y-\\overline{y}) + g^{\\prime}_e \\epsilon_t \\]\n\nWe can obtain the unknown quantities \\(g^{\\prime}_y\\), and \\(g^{\\prime}_e\\) using the method of undeterminate coefficients:\nPlug the first approximation into the system and write the conditions \\[F^{\\prime}_y(\\overline{y}, 0) = 0\\] \\[F^{\\prime}_\\epsilon(\\overline{y}, 0) = 0\\]"
  },
  {
    "objectID": "slides/session_1/index.html#computing-gprime_y",
    "href": "slides/session_1/index.html#computing-gprime_y",
    "title": "Solving DSGE models",
    "section": "Computing \\(g^{\\prime}_y\\)",
    "text": "Computing \\(g^{\\prime}_y\\)\nRecall the system: \\[F(y,\\epsilon) = f(g(g(y,0),\\epsilon), g(y,\\epsilon), y, \\epsilon) = 0\\]\nWe have \\[F^{\\prime}_y(\\overline{y}, 0) = f^{\\prime}_{y_{t+1}} g^{\\prime}_y g^{\\prime}_y + f^{\\prime}_{y_{t}} g^{\\prime}_y + f^{\\prime}_{y_{t-1}} = 0 \\]\n\nThis is a specific Riccatti equation \\[A X^2 + B X + C\\] where \\(A,B,C\\) and \\(X=g^{\\prime}_y\\) are square matrices \\(\\in \\mathbb{R}^n \\times \\mathbb{R}^n\\)"
  },
  {
    "objectID": "slides/session_1/index.html#first-order-deterministic-model",
    "href": "slides/session_1/index.html#first-order-deterministic-model",
    "title": "Solving DSGE models",
    "section": "First Order Deterministic Model",
    "text": "First Order Deterministic Model\nLet’s pause a minute to observe the first order deterministic model: \\[A X^2 + B X + C\\]\nFrom our intuition in dimension 1, we know there must be multiple solutions\n\nhow do we find them?\nhow do we select the right ones?\n\nI the absence of shocks the dynamics of the model are given by \\[y_t = X y_{t-1}\\]\nWhat is the condition for the model to be stationary?\n\n-&gt; the biggest eigenvalue of \\(X\\) should be smaller than 1\n\nDevelop intuition in dimension 1."
  },
  {
    "objectID": "slides/session_1/index.html#multiplicity-of-solution",
    "href": "slides/session_1/index.html#multiplicity-of-solution",
    "title": "Solving DSGE models",
    "section": "Multiplicity of solution",
    "text": "Multiplicity of solution\nIt is possible to show that the system is associated with \\(2 n\\) generalized eigenvalues:\n\\[|\\lambda_1| \\leq \\cdots \\leq |\\lambda_{2 n}|\\]\nFor each choice \\(C\\) of \\(n\\) eigenvalues (\\(|C|=n\\)), a specific recursive solution \\(X_C\\) can be constructed. It has eigenvalues \\(C\\).\n\nThis yields at least \\(\\left(\\begin{matrix} 2 n \\\\ n \\end{matrix}\\right)\\) different combinations.\n\n\nA model is well defined when there is exactly one solution that is non divergent.\nThis is equivalent to:\n\\[|\\lambda_1| \\leq \\cdots \\leq |\\lambda_{n}| \\leq 1 &lt; |\\lambda_{n+1}| \\leq \\cdots \\leq |\\lambda_{2 n}|\\]"
  },
  {
    "objectID": "slides/session_1/index.html#example-1",
    "href": "slides/session_1/index.html#example-1",
    "title": "Solving DSGE models",
    "section": "Example 1",
    "text": "Example 1\nForward looking inflation:\n\\[\\pi_t = \\alpha \\pi_{t+1}\\] with \\(\\alpha&lt;1\\).\nIs it well defined?\n\nWe can rewrite the system as:\n\\[\\alpha \\pi_{t+1} - \\pi_t + 0 \\pi_{t-1}  = 0\\]\nor\n\\[\\pi_{t+1} - (\\frac{1}{\\alpha} + 0 )\\pi_t + \\left(\\frac{1}{\\alpha} 0\\right) \\pi_{t-1} = 0\\]\n\n\nThe generalized eigenvalues are \\(0\\leq 1 &lt; \\frac{1}{\\alpha}\\).\n\n\nThe unique stable solution is \\(\\pi_t=0 \\pi_{t-1}\\)"
  },
  {
    "objectID": "slides/session_1/index.html#example-2",
    "href": "slides/session_1/index.html#example-2",
    "title": "Solving DSGE models",
    "section": "Example 2",
    "text": "Example 2\nDebt accumulation equation by a rational agent:\n\\[b_{t+1} - (1+\\frac{1}{\\beta}) b_t + \\frac{1}{\\beta} b_{t-1} = 0\\]\nIs it well-defined?\n\nTwo generalized eigenvalues \\(\\lambda_1=1 &lt; \\lambda_2=\\frac{1}{\\beta}\\)\n\n\nThe unique non-diverging solution is \\(b_t = b_{t-1}\\).\n\nit is a unit-root: any initial deviation in \\(b_{t-1}\\) has persistent effects"
  },
  {
    "objectID": "slides/session_1/index.html#example-3",
    "href": "slides/session_1/index.html#example-3",
    "title": "Solving DSGE models",
    "section": "Example 3",
    "text": "Example 3\nProductivity process: \\[z_t = \\rho z_{t-1}\\] with \\(\\rho&lt;1\\): well defined\n\nIn that case there is a hidden infinite eigenvalue \\(\\infty\\) associated to \\(z_{t+1}\\).\n\n\nTo see why consider the system associated with eigenvalues \\(m\\) and \\(\\rho\\): \\[z_{t+1} - (m+\\rho) z_t + m \\rho z_{t-1} = 0\\]\n\\[\\frac{1}{m} z_{t+1} - (1+\\frac{\\rho}{m}) z_t + \\rho z_{t-1} = 0\\]\nWhich corresponds to the initial model when \\(m=\\infty\\)\n\n\nThe generalized eigenvalues are \\(\\lambda_1 = \\rho \\leq 1 &lt; \\lambda_2 = \\infty\\)\nMore generally, any variable that does not appear in \\(t+1\\) creates one infinite generalized eigenvalue."
  },
  {
    "objectID": "slides/session_1/index.html#a-criterium-for-well-definedness",
    "href": "slides/session_1/index.html#a-criterium-for-well-definedness",
    "title": "Solving DSGE models",
    "section": "A criterium for well-definedness",
    "text": "A criterium for well-definedness\nLooking again at the list of eigenvalues we set aside the infinite ones.\nThe model is well specified iff we can sort the eigenvalues as:\n\\[|\\lambda_1| \\leq \\cdots \\leq |\\lambda_{n}| \\leq 1 &lt; |\\lambda_{n+1}| \\leq \\cdots  |\\lambda_{n+k}| \\leq \\underbrace{|\\lambda_{n+k+1}| \\cdots \\leq |\\lambda_{2 n}|}_{\\text{infinite eigenvalues}}\\]\n\n\n\n\n\n\nBlanchard-Kahn criterium\n\n\nThe model satisfies the Blanchard-Kahn criterium if the number of eigenvalues greater than one, is exactly equal to the number of variables appearing in \\(t+1\\).\nIn that case the model is well-defined."
  },
  {
    "objectID": "slides/session_1/index.html#computing-the-solution",
    "href": "slides/session_1/index.html#computing-the-solution",
    "title": "Solving DSGE models",
    "section": "Computing the solution",
    "text": "Computing the solution\nThere are several classical methods to compute the solution to the algebraic Riccatti equation: \\[A X^2+ B X + C=0\\]\n\nqz decomposition\n\ntraditionnally used in the DSGE literature since Chris Sims\na little bit unintuitive\n\ncyclic reduction\n\nnew default in dynare, more adequate for big models\n\nlinear time iteration cf @sec:linear_time_iteration\n\nconceptually very simple"
  },
  {
    "objectID": "slides/session_1/index.html#computing-gprime_e",
    "href": "slides/session_1/index.html#computing-gprime_e",
    "title": "Solving DSGE models",
    "section": "Computing \\(g^{\\prime}_{e}\\)",
    "text": "Computing \\(g^{\\prime}_{e}\\)\nNow we have \\(g^{\\prime}_y\\), how do we get \\(g^{\\prime}_{e}\\)?\nRecall: \\[F(y,\\epsilon) = f(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon) = 0\\]\nWe have \\[F^{\\prime}_e(\\overline{y}, 0) =  f^{\\prime}_{y_{t+1}}  g^{\\prime}_y  g^{\\prime}_e + f^{\\prime}_{y_{t}} g^{\\prime}_e + f^{\\prime}_{\\epsilon_t} = 0 \\]\nNow this is easy:\n\\[g^{\\prime}_e = - (f^{\\prime}_{y_{t+1}}  g^{\\prime}_y + f^{\\prime}_{y_{t}} )^{-1}  f^{\\prime}_{\\epsilon_t} = 0 \\]"
  },
  {
    "objectID": "slides/session_1/index.html#the-model-solution",
    "href": "slides/session_1/index.html#the-model-solution",
    "title": "Solving DSGE models",
    "section": "The model solution",
    "text": "The model solution\nThe result of the model solution: \\[y_t = g_y y_{t-1} + g_e \\epsilon_t\\]\nIt is an AR1, driven by exogenous shock \\(\\epsilon_t\\).\n\nBecause it is a well known structure, one can investigate the model with\n\nimpulse response functions\nstochastic simulations\n\n\n\nThen to compare the model to the data we compute\n\nimplied moments:\n\ncovariances, autocorrelation\n\nlikelihood\n\nOptimizing the fit to the data is called model estimation"
  },
  {
    "objectID": "slides/session_1/index.html#what-can-you-do-with-the-solution",
    "href": "slides/session_1/index.html#what-can-you-do-with-the-solution",
    "title": "Solving DSGE models",
    "section": "What can you do with the solution",
    "text": "What can you do with the solution\nThe solution of a model found by Dynare has an especially simple form: an AR1\n\n\\(y_t = X y_{t-1} + Y \\epsilon_t\\)\nwhere the covariances \\(\\Sigma\\) of \\(\\epsilon_t\\) can be chosen by the modeler\n\n\nWith this solution we can (cf next TD)\n\ncompute (conditional and unconditional) moments\nperform stochastic simulations, impulse response function"
  },
  {
    "objectID": "slides/session_1/index.html#going-further",
    "href": "slides/session_1/index.html#going-further",
    "title": "Solving DSGE models",
    "section": "Going Further",
    "text": "Going Further\nTaking the model to the data with Dynare\n\n“estimate” the model: compute the likelihood of a solution and maximize it by choosing the right parameters\n“identify” shocks in the data\n\nOther functions\n\nhigher order approximation\n(noninear) perfect foresight simulations\nramsey plan\ndiscretionary policy\n…"
  },
  {
    "objectID": "slides/session_1/index.html#coming-next",
    "href": "slides/session_1/index.html#coming-next",
    "title": "Solving DSGE models",
    "section": "Coming Next",
    "text": "Coming Next\n\nMany models"
  },
  {
    "objectID": "slides/session_1/index.html#linear-time-iteration",
    "href": "slides/session_1/index.html#linear-time-iteration",
    "title": "Solving DSGE models",
    "section": "Linear Time Iteration",
    "text": "Linear Time Iteration\nRecall the system to solve: \\[F(y,\\epsilon) = f(g(g(y,\\epsilon),0), g(y,\\epsilon), y, \\epsilon) = 0\\]\nbut now assume the decision rules today and tomorrow are different:\n\ntoday: \\(y_t = g(y_{t-1}, \\epsilon_t) = \\overline{y} + X y_{t-1} + g_y \\epsilon_t\\)\ntomorrow: \\(y_{t+1} = \\tilde{g}(y_t, \\epsilon_{t+1}) = \\overline{y} + \\tilde{X} y_{t-1} + \\tilde{g}_y \\epsilon_t\\)\n\nThen the Ricatti equation is written:\n\\[A \\tilde{X} X + B X + C = 0\\]"
  },
  {
    "objectID": "slides/session_1/index.html#linear-time-iteration-2",
    "href": "slides/session_1/index.html#linear-time-iteration-2",
    "title": "Solving DSGE models",
    "section": "Linear Time Iteration (2)",
    "text": "Linear Time Iteration (2)\nThe linear time iteration algorithm consists in solving the decision rule \\(X\\) today as a function of decision rule tomorrow \\(\\tilde{X}\\).\nThis corresponds to the simple formula:\n\\[X = -(A\\tilde{X} + B)^{-1} C\\]\nAnd the full algorithm can be described as:\n\nchoose \\(X_0\\)\nfor any \\(X_n\\), compute \\(X_{n+1} = T(X_n) = -(A X_n + B)^{-1} C\\)\n\nrepeat until convergence"
  },
  {
    "objectID": "slides/session_1/index.html#linear-time-iteration-3",
    "href": "slides/session_1/index.html#linear-time-iteration-3",
    "title": "Solving DSGE models",
    "section": "Linear Time Iteration (3)",
    "text": "Linear Time Iteration (3)\nIt can be shown that, starting from a random initial guess, the linear time-iteration algorithm converges to the solution \\(X\\) with the smallest modulus:\n\\[\\underbrace{|\\lambda_1| \\leq \\cdots  \\leq |\\lambda_n|}_{\\text{Selected eigenvalues}} \\leq |\\lambda_{n+1}|\\cdots \\leq |\\lambda_{2n}|\\]\nIn other words, it finds the right solution when the model is well specified.\nHow do you check it is well specified?\n\n\\(\\lambda_n\\) is the biggest eigenvalue of solution \\(X\\)\nwhat about \\(\\lambda_{n+1}\\)?\n\n\\(\\frac{1}{\\lambda_{n+1}}\\) is the biggest eigenvalue of \\((AX+B)^{-1}A\\)"
  },
  {
    "objectID": "slides/session_1/index.html#linear-time-iteration-4",
    "href": "slides/session_1/index.html#linear-time-iteration-4",
    "title": "Solving DSGE models",
    "section": "Linear Time Iteration (4)",
    "text": "Linear Time Iteration (4)\nDefine \\[M(\\lambda) = A\\lambda^2 + B \\lambda + C\\]\nFor any solution \\(X\\), \\(M(\\lambda)\\) can be factorized as: 1\n\\[M(\\lambda)=(\\lambda A + A X + B)(\\lambda I -X)\\]\nand\n\\[det(M(\\lambda)) = \\underbrace{det(\\lambda A + A X + B)}_{Q(\\lambda)}det(\\lambda I -X)\\]\nBy construction \\(Q(\\lambda)\\) is a polynomial whose roots are those that are not selected by the solution i.e. \\(\\Lambda\\setminus Sp(X)\\).\nSpecial case of Bezout theorem. Easy to check in that case"
  },
  {
    "objectID": "slides/session_1/index.html#linear-time-iteration-5",
    "href": "slides/session_1/index.html#linear-time-iteration-5",
    "title": "Solving DSGE models",
    "section": "Linear Time Iteration (5)",
    "text": "Linear Time Iteration (5)\nFor \\(\\lambda \\neq 0\\) we have:\n\\[\\lambda \\in Sp((A X +B )^{-1} A)\\] \\[\\iff  det( (A X +B )^{-1})A - I\\lambda )=0\\] \\[\\iff  det( \\frac{1}{\\lambda} A - I (A X +B )  )=0\\] \\[\\iff Q(\\frac{1}{\\lambda})=0\\] \\[\\iff \\frac{1}{\\lambda} \\in G \\setminus Sp(X)\\]\nIn words, \\((AX+B)^{-1}\\) contains all the eigenvalues that have been rejected by the selection of \\(X\\).\nIn particular, \\(\\rho((AX+B)^{-1})A)=1/\\min(G\\setminus Sp(X))\\)"
  },
  {
    "objectID": "tutorials/session_1/problem.html",
    "href": "tutorials/session_1/problem.html",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "",
    "text": "Objectives\n\n\n\n\n\n\nIntroduce Julia environment\n\nrun cells\nbasic types: numbers, strings, vectors, matrices\nfunctions\nsimple plots\n\nSimulate AR1 models\n\nimpulse response functions\nstochastic simulations\n\nconditional / unconditional moments\n\ndevelop intuition about eigenvalues / ergodic distributions\n\nLearn the Dyno mini-interface\n\ncheck the steady-state\nunderstand the meaning of shocks (exogenous variables, innovations)\nunderstand the outputs (decision rule, simulation, graphs)\ninterpret IRFs (persistence, magnitude, …)",
    "crumbs": [
      "tutorials",
      "Intro to DSGE Model & Julia Basics"
    ]
  },
  {
    "objectID": "tutorials/session_1/problem.html#why-julia",
    "href": "tutorials/session_1/problem.html#why-julia",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Why Julia?",
    "text": "Why Julia?\nDevelopped at MIT on top of opensource technologies\n\nlinux / git / llvm\n\nSyntax inspired by Matlab but:\n\nmore consistent\nlots of features from high level languages\n\nEverything is JIT-compiled\n\nno interpreted vs compiled treadeoff -&gt; very fast\nmost of the base library is written in Julia\n\nOpensource/free + vibrant community",
    "crumbs": [
      "tutorials",
      "Intro to DSGE Model & Julia Basics"
    ]
  },
  {
    "objectID": "tutorials/session_1/problem.html#numbers",
    "href": "tutorials/session_1/problem.html#numbers",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Numbers",
    "text": "Numbers\n\n# numbers (usual operations usual)\n(1.0+(2.0+3.0*(4.0+5.0)))/30\n\n1.0\n\n\n\n# exponentials are denoted by ^\n2^8\n\n256",
    "crumbs": [
      "tutorials",
      "Intro to DSGE Model & Julia Basics"
    ]
  },
  {
    "objectID": "tutorials/session_1/problem.html#variables-assignments-comparisons",
    "href": "tutorials/session_1/problem.html#variables-assignments-comparisons",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Variables / assignments / comparisons",
    "text": "Variables / assignments / comparisons\n\n# variable assignment\nx = 10\n\n10\n\n\n\n# Variable names can have Unicode characters\n# To get ϵ in the REPL, type \\epsilon&lt;TAB&gt;\na = 20\nσ = 34\nϵ = 1e-4\n\n0.0001\n\n\n\n# comparison \n2 == 3\n\nfalse\n\n\n\n3&lt;=3\n\ntrue",
    "crumbs": [
      "tutorials",
      "Intro to DSGE Model & Julia Basics"
    ]
  },
  {
    "objectID": "tutorials/session_1/problem.html#strings",
    "href": "tutorials/session_1/problem.html#strings",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Strings",
    "text": "Strings\n\n# Strings can also contain Unicode characters\nfancy_str = \"α is a string\"\n\n\"α is a string\"\n\n\n\n# double quotes define a character, not a string\n'c' \n\n'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n\n\n\n# string interpolation (1/2)\nhe_who_must_not_be_named = \"Voldemort\"\n\"Welcome $(he_who_must_not_be_named)!\"\n\n\"Welcome Voldemort!\"\n\n\n\n# string interpolation (2/2)\nn = 1999999\nprintln(\"Iteration \", n, \" is still running...\")\n\nIteration 1999999 is still running...",
    "crumbs": [
      "tutorials",
      "Intro to DSGE Model & Julia Basics"
    ]
  },
  {
    "objectID": "tutorials/session_1/problem.html#arrays",
    "href": "tutorials/session_1/problem.html#arrays",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Arrays",
    "text": "Arrays\n\n# vectors\nv = [1,2,3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n# matrices \nM = [1 2 3 ; 4 5 6 ; 7 8 9]\n\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\n\n\n# matrix multiplication\nM*v\n\n3-element Vector{Int64}:\n 14\n 32\n 50\n\n\n\n# mutating vectors\nx = [\"One\"]\npush!(x, \"Two\")\npush!(x, \"Three\")\npush!(x, \"Four\")\npush!(x, \"Five\")\n\n# Note how the type of the vector is different from above\n# Vectors in Julia hold homoegenous types\n\n# Also note the exclation mark in `push!`: it is a reminder\n# of the fact that `push!` mutates its first argument\n\n5-element Vector{String}:\n \"One\"\n \"Two\"\n \"Three\"\n \"Four\"\n \"Five\"\n\n\n\n# access elements in a vector\nv[1]\n\n1\n\n\n\n# access elements in a matrix\nM[1,2]\n\n2\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIndexing in Julia is 1-based. First element of a collection is denoted by 1.\n\n\n\n# slice matrices\nprintln(M)\n\n# keep first line\nprintln(\"First line\")\nprintln(M[1,:])\n\n# keep second column\nprintln(\"Second column\")\nprintln(M[:,2])\n\n# extract a submatrix\nprintln(M[1:2,1:2])\n\n[1 2 3; 4 5 6; 7 8 9]\nFirst line\n[1, 2, 3]\nSecond column\n[2, 5, 8]\n[1 2; 4 5]\n\n\n\n# concatenate vectors (horizontally)\nvcat( [1,2], [3,4])\n\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n\n# concatenate vectors\nhcat( [1,2], [3,4])\n\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\n\n\n# transpose matrix\nhcat( [1,2], [3,4])'\n\n2×2 adjoint(::Matrix{Int64}) with eltype Int64:\n 1  2\n 3  4",
    "crumbs": [
      "tutorials",
      "Intro to DSGE Model & Julia Basics"
    ]
  },
  {
    "objectID": "tutorials/session_1/problem.html#tuples",
    "href": "tutorials/session_1/problem.html#tuples",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Tuples",
    "text": "Tuples\n\n# like in python\n# tuples can hold heterogenous data\nt = (\"This\", \"is\", 1, \"tuple\")\n\n(\"This\", \"is\", 1, \"tuple\")\n\n\n\n# access elements in a tuple (still 1-based)\nt[3]\n\n1\n\n\n\n# tuples are `immutable`\n# The following should raise an exception\npush!(t, \"not a vector\")\n\nMethodError: MethodError: no method matching push!(::Tuple{String, String, Int64, String}, ::String)\n\nClosest candidates are:\n  push!(::Any, ::Any, !Matched::Any)\n   @ Base abstractarray.jl:3389\n  push!(::Any, ::Any, !Matched::Any, !Matched::Any...)\n   @ Base abstractarray.jl:3390\n  push!(!Matched::Set, ::Any)\n   @ Base set.jl:103\n  ...",
    "crumbs": [
      "tutorials",
      "Intro to DSGE Model & Julia Basics"
    ]
  },
  {
    "objectID": "tutorials/session_1/problem.html#loops",
    "href": "tutorials/session_1/problem.html#loops",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Loops",
    "text": "Loops\n\n# loop over any iterable (like in python)\nfor i in 1:5\n    println(\"Iteration \", i)\nend\n# note how 1 and 5 are both included.\n\nIteration 1\nIteration 2\nIteration 3\nIteration 4\nIteration 5\n\n\n\nfor i ∈ [\"Paris\", \"New-York\", \"Bogota\"]\n    println(\"City: \", i)\nend\n\nCity: Paris\nCity: New-York\nCity: Bogota\n\n\n\n# Vector comprehensions (like in python)\n# enumerate all squares of even numbers (% computes modulo)\n[i^2 for i=1:10 if i%2==1]\n\n5-element Vector{Int64}:\n  1\n  9\n 25\n 49\n 81",
    "crumbs": [
      "tutorials",
      "Intro to DSGE Model & Julia Basics"
    ]
  },
  {
    "objectID": "tutorials/session_1/problem.html#functions",
    "href": "tutorials/session_1/problem.html#functions",
    "title": "Intro to DSGE Model & Julia Basics",
    "section": "Functions",
    "text": "Functions\n\n# matlab like syntax\n# with positional and keyword arguments separated by `;`\n\nfunction fun(a,b; c=3)\n    z = a+b*c\n    return z\nend\n\nfun (generic function with 1 method)\n\n\n\nfun(1,2)\n\n7\n\n\n\nfun(1,2; c=4)\n\n9",
    "crumbs": [
      "tutorials",
      "Intro to DSGE Model & Julia Basics"
    ]
  }
]